---
title: "Prompt Library"
editor: visual
---

## Spec-Driven Development Workflow

::: {.callout-tip}
## Quick Copy Prompts
All prompts below are in copyable code blocks. Just click to select and copy the entire prompt, then fill in the bracketed placeholders with your specific details.
:::

### Meta Prompt: Generate Custom Prompts

Use this to create tailored prompts for your specific project context:

```
I need you to create a detailed prompt that will help me [specific task].

Context about my project:
- Product: [description]
- Tech stack: [technologies]
- Current phase: [discovery/design/implementation]
- Key constraints: [list any constraints]

The prompt should:
1. Guide me to think through all critical aspects
2. Help me avoid common pitfalls
3. Produce output in [desired format]
4. Be reusable for similar tasks

Generate a comprehensive prompt I can use with an LLM to accomplish this task.
```

### Product Requirements Document (PRD)

```
Create a comprehensive Product Requirements Document for [product/feature name].

Product Context:
- Problem we're solving: [problem description]
- Target users: [user personas]
- Business goals: [key metrics/objectives]
- Technical constraints: [technologies, dependencies, integrations]

Generate a PRD that includes:

1. **Executive Summary**
   - Product vision in 2-3 sentences
   - Key success metrics

2. **Problem Statement**
   - User pain points with evidence/data
   - Current solutions and their limitations
   - Opportunity size

3. **Goals and Non-Goals**
   - What this WILL accomplish
   - What this explicitly WON'T do (scope boundaries)

4. **User Stories and Use Cases**
   - Primary user flows
   - Edge cases to consider

5. **Requirements**
   - Functional requirements (must-haves)
   - Non-functional requirements (performance, security, scalability)
   - Dependencies on other systems

6. **Success Metrics**
   - How we'll measure if this is working
   - Target values for each metric

7. **Technical Considerations**
   - Architecture implications
   - Data models required
   - API requirements
   - Security and compliance needs

8. **Open Questions**
   - Unresolved decisions
   - Areas needing research

Format the entire document in clean markdown with clear headers and bullet points.
```

### User Stories

```
Generate comprehensive user stories for [feature name].

Context:
- User personas: [describe your users]
- Feature purpose: [what problem does this solve]
- Technical platform: [web/mobile/API/etc]

For each user story, use this format:

**As a** [specific user role/persona]
**I want to** [specific action/capability]
**So that** [clear benefit/value]

**Acceptance Criteria:**
- Given [precondition]
- When [action/trigger]
- Then [expected outcome]

Generate 5-10 user stories covering:
1. Happy path scenarios
2. Edge cases
3. Error conditions
4. Different user permissions/roles

Make each story atomic, testable, and independent.
```

### EARS Format Requirements

```
Convert the following feature requirements into EARS (Easy Approach to Requirements Syntax) format:

[Paste your rough requirements here]

For each requirement, use the appropriate EARS template:

**Ubiquitous Requirements** (always active):
"The [system] SHALL [requirement]"

**Event-driven Requirements:**
"WHEN [trigger/event] THEN the [system] SHALL [requirement]"

**State-driven Requirements:**
"WHILE [in a specific state] the [system] SHALL [requirement]"

**Unwanted Behaviors:**
"IF [unwanted condition occurs] THEN the [system] SHALL [requirement]"

**Optional Features:**
"WHERE [feature is included] the [system] SHALL [requirement]"

Make each requirement:
- Specific and measurable
- Testable with clear pass/fail criteria
- Independent of implementation details
- Traceable to user stories
```

### Technical Architecture

```
Design a technical architecture for [product/feature].

Current Stack:
- Frontend: [framework]
- Backend: [framework]
- Database: [type]
- Infrastructure: [cloud/hosting]

Feature Requirements:
[List key functional requirements]

Provide a comprehensive architecture document including:

1. **System Overview**
   - High-level architecture diagram (use Mermaid or text description)
   - Key components and their responsibilities
   - Data flow between components

2. **Component Design**
   - Frontend components and state management
   - Backend services and API structure
   - Database schema and relationships
   - External integrations

3. **API Specification**
   - Endpoint definitions (REST/GraphQL)
   - Request/response formats
   - Authentication/authorization approach

4. **Data Models**
   - Entity definitions
   - Relationships and constraints
   - Validation rules

5. **Error Handling Strategy**
   - How errors are caught and reported
   - User-facing error messages
   - Logging and monitoring approach

6. **Security Considerations**
   - Authentication method
   - Authorization rules
   - Data encryption
   - Input validation

7. **Testing Strategy**
   - Unit test approach
   - Integration test scenarios
   - E2E test coverage

Format in clean markdown with Mermaid diagrams where helpful.
```

### Implementation Task List

```
Break down this feature into granular, test-driven implementation tasks:

Feature: [name]
Requirements: [reference requirements doc or list key requirements]
Architecture: [reference design doc or summarize approach]

Create a numbered task list where each task:

1. **Is small and focused** - Can be completed in 30-60 minutes
2. **Follows TDD** - Write test first, then implementation
3. **Is independently testable** - Has clear pass/fail criteria
4. **References requirements** - Traces to specific requirement IDs
5. **Builds incrementally** - Each task adds working functionality

Format as:
- [ ] 1. Task description
  - Subtask or implementation note
  - _Requirements: [requirement IDs]_

- [ ] 2. Next task
  - [ ] 2.1 Subtask if needed
    - Implementation details
    - _Requirements: [requirement IDs]_

Focus ONLY on coding tasks (writing/modifying/testing code). Exclude:
- Documentation writing
- User testing
- Deployment configuration
- Performance monitoring setup

Start with foundational tasks (interfaces, data models) and build up to features.
```

### Data Model Design

```
Design a comprehensive data model for [feature/system].

Entities needed:
[List main entities: User, Post, Comment, etc.]

For each entity, provide:

1. **Entity Name** and description
2. **Attributes:**
   - Field name
   - Data type
   - Constraints (required, unique, min/max, etc.)
   - Default values
   - Validation rules

3. **Relationships:**
   - Related entities
   - Relationship type (one-to-one, one-to-many, many-to-many)
   - Foreign keys
   - Cascade behavior

4. **Indexes:**
   - Fields that should be indexed
   - Composite indexes if needed

5. **Sample Data:**
   - 2-3 example records showing realistic data

Use this format:
```typescript
interface EntityName {
  id: string;              // UUID, primary key
  fieldName: string;       // description, constraints
  // ... more fields
}
```

Include Mermaid ER diagram showing relationships.
```

### API Design

```
Design a RESTful API for [feature/system].

Resources:
[List main resources: users, posts, comments, etc.]

For each endpoint, provide:

**Endpoint:** `[METHOD] /api/resource`
**Description:** What this endpoint does
**Authentication:** Required? Type?
**Request:**
```json
{
  "field": "type and description"
}
```
**Response:** `200 OK`
```json
{
  "field": "type and description"
}
```
**Error Responses:**
- `400 Bad Request` - Invalid input
- `401 Unauthorized` - Missing/invalid auth
- `404 Not Found` - Resource doesn't exist

**Validation Rules:**
- Field requirements
- Format constraints

Include:
1. All CRUD operations for main resources
2. Authentication endpoints
3. Any special operations (search, bulk actions, etc.)
4. Rate limiting approach
5. Pagination strategy for list endpoints
```

### Test Cases

```
Generate comprehensive test cases for [feature/component].

Context:
- Requirements: [key requirements]
- Component type: [UI component/API/service/etc.]

Provide test cases in three categories:

**Unit Tests:**
- [ ] Test 1: [description]
  - Setup: [preconditions]
  - Action: [what to do]
  - Expected: [what should happen]
  - Requirements: [IDs]

**Integration Tests:**
- [ ] Test 1: [description of component interaction]
  - Setup: [system state]
  - Action: [sequence of operations]
  - Expected: [end result]
  - Requirements: [IDs]

**Edge Cases:**
- [ ] Empty inputs
- [ ] Maximum values
- [ ] Invalid data
- [ ] Concurrent operations
- [ ] Network failures

Make each test:
- Independent (can run in any order)
- Repeatable (same result every time)
- Fast (no unnecessary delays)
- Clear (obvious what's being tested)
```

## Architecture

Open ChatGPT (4o, not o1/o3/o4) and say:

‚Äú I‚Äôm building a [description of your product - the more detailed the better]. Use Next.js for frontend, Supabase for DB + auth. 

Give me the full architecture:

- File + folder structure
- What each part does
- Where state lives, how services connect

Format this entire document in markdown.‚Äù

Save its output as architecture.md and throw it in an empty folder where your project will live.

## Tasks

‚Äú Using that architecture, write a granular step-by-step plan to build the MVP.
Each task should:

- Be incredibly small + testable
- Have a clear start + end
- Focus on one concern

I‚Äôll be passing this off to an engineering LLM that will be told to complete one task at a time, allowing me to test in between. "

Save it as tasks.md. Again, throw it in the folder.

## Engineering

Step 3: In Cursor/Windsurf

‚Äú You‚Äôre an engineer building this codebase.

You've been given architecture.md and tasks.md.

- Read both carefully. There should be no ambiguity about what we‚Äôre building.
- Follow http://tasks.md and complete one task at a time.
- After each task, stop. I‚Äôll test it. If it works, commit to GitHub and move to the next. "

Include this as well - this is crucial:

 CODING PROTOCOL

" Coding Instructions

- Write the absolute minimum code required
- No sweeping changes
- No unrelated edits - focus on just the task you're on
- Make code precise, modular, testable
- Don‚Äôt break existing functionality
- If I need to do anything (e.g. Supabase/AWS config), tell me clearly  "

This system fixes the biggest problem with vibe coding:

You‚Äôre not dumping everything into the IDE and praying.
You‚Äôre giving it a roadmap.
You‚Äôre keeping it on rails.
You stay in control.

This workflow lets you ship clean, testable AI-assisted code - without the spiral.

Normally I'd ask you to follow me for the playbook but this is literally it. Good luck

[Source: vasumanmoza on X](https://x.com/vasumanmoza/status/1923912878370980115?s=51&t=miuEnFRF6fTUR36WiwEysw)


::: {.callout-note collapse=true}
## Icons

[AirBnB-style icons with ChatGPT-4o in 60 seconds üëá](https://www.linkedin.com/posts/nigolos_ffffff-activity-7331341131089076226-G6AC?utm_source=share&utm_medium=member_desktop&rcm=ACoAAABxVuoByW5PDRHey5Wh_ef3dPtGKfJRCmw)

I used just ONE simple prompt to create 3D isometric illustrations that feel like Pixar vibes mixed with modern, minimal design.

Use this prompt:

--

Generate [ Your Concept ] icon with this JSON style:

```{json}
{  
  "icon_style": {  
    "perspective": "isometric",  
    
    "geometry": {  
      "proportions": "1:1 ratio canvas, with objects fitting comfortably within margins",  
      "element_arrangement": "central dominant object, with supporting elements symmetrically or diagonally placed"  
    },  
    
    "composition": {  
      "element_count": "2‚Äì4 main objects",  
      "spatial_depth": "layered to create sense of dimension and slight elevation",  
      "scale_consistency": "uniform object scale across icon set",  
      "scene_density": "minimal to moderate, maintaining clarity and visual focus"  
    },  
    
    "lighting": {  
      "type": "soft ambient light",  
      "light_source": "subtle top-right or front-top direction",  
      "shadow": "gentle drop shadows below and behind objects",  
      "highlighting": "mild edge illumination to define forms"  
    },  
    
    "textures": {  
      "material_finish": "semi-matte to satin surfaces",  
      "surface_treatment": "smooth with light tactile variation (e.g., wood grain, soft textures)",  
      "texture_realism": "stylized naturalism without hyper-realistic noise"  
    },  
    
    "render_quality": {  
      "resolution": "high-resolution octane 3D rendering",  
      "edge_definition": "crisp, no outlines; separation achieved via lighting and depth",  
      "visual_clarity": "clean, readable shapes with minimal clutter"  
    },  
    
    "color_palette": {  
      "tone": "naturalistic with slight saturation boost",  
      "range": "harmonious muted tones with gentle contrast",  
      "usage": "distinct colors per object to improve identification and readability"  
    },  
    
    "background": {  
      "color": "hashtag#FFFFFF",  
      "style": "pure white, flat",  
      "texture": "none"  
    },  
    
    "stylistic_tone": "premium, friendly, clean with lifestyle or service-oriented appeal",  
    
    "icon_behavior": {  
      "branding_alignment": "neutral enough for broad applications",  
      "scalability": "legible at small and medium sizes",  
      "interchangeability": "part of a cohesive icon system with interchangeable subject matter"  
    }  
  }  
}
```

--

Just swap [ Your Concept ] with what you want:
‚Ä¢ ‚Äúcoffee shop‚Äù
‚Ä¢ ‚Äúbike rental‚Äù
‚Ä¢ ‚Äúco-working space‚Äù

And just like that, high-end, Airbnb-style icons are ready in seconds.
This might be the easiest design cheat code of 2025.

:::


## AI Workflows

::: {.callout-note collapse=true}

## Cursor Workflow

[Stanislav Beliaev CTO of GetFluently.App](https://www.linkedin.com/posts/stasbel_how-to-make-cursor-10x-more-useful-with-this-activity-7331676675308511232-ym7p/)

How to make Cursor 10x more useful with this one system üëá

At Fluently (AI English Coach ‚Üí https://getfluently.app) we use Cursor to streamline our development process.

By following these proven practices, you can ship features in hours, not days.

‚Üí Before using Cursor:

‚Ä¢ Ask Claude (or ChatGPT) to create a clear, detailed plan in markdown
‚Ä¢ Have the AI ask clarifying questions, critique its own plan, and regenerate if needed
‚Ä¢ Save this plan as "instructions. md" for easy reference during development.
‚Ä¢ Use ChatGPT to add an extra planning layer before coding by another AI, reducing errors and complexity.

‚Üí Workflow and incremental development:

Break work into small, manageable tasks or feature increments.

Use an Edit-Test loop:
1. Write a failing test case first (TDD approach).
2. Instruct AI to write code to pass the test.
3. Run the test.
4. If it fails, AI analyzes failure and fixes code.
5. Repeat until tests pass.

Review AI-generated changes after tests pass.
Encourage AI to explain its chain of thought in prompts.

‚Üí Debugging

‚Ä¢ If stuck, ask Cursor to generate a detailed report of all files and their roles, including errors.
‚Ä¢ Use ChatGPT or Claude to analyze the report and suggest fixes.
‚Ä¢ Use tools like gitingest.com to collect all scripts, configs, and relevant files in a single page for easier AI ingestion.
‚Ä¢ Refer to the latest documentation via context7.com for up-to-date info.

‚Üí Cursor-specific tips

‚Ä¢ Use CursorRules to set broad project rules (always in AI context). Search Cursor Directory for examples.
‚Ä¢ Typical rule: Write tests ‚Üí write code ‚Üí run tests ‚Üí update code until tests pass.
‚Ä¢ Use /Reference open editors to quickly add files to AI context.
‚Ä¢ Use cursorignore to exclude irrelevant files.
‚Ä¢ Keep context short by explicitly adding files via @. Longer context can confuse AI.
‚Ä¢ Start new chats when the context becomes too long.
‚Ä¢ Resync or reindex code frequently to keep AI up to date.
‚Ä¢ Notepads are useful for frequently used prompts.

‚Üí Version control and file management

‚Ä¢ Use Git often to commit changes regularly.
‚Ä¢ Avoid large sets of uncommitted changes.
‚Ä¢ Creating files and folders (e.g., touch, mkdir) is always acceptable.
‚Ä¢ Running tests (Vitest, PM test, NR test, build, tsc) is always allowed.

‚Üí Optional settings and modes

Enable YOLO mode to have AI write tests automatically.

Use a system prompt in "Rules for AI" in Cursor settings:
‚Ä¢ Keep answers concise and direct.
‚Ä¢ Suggest alternative solutions.
‚Ä¢ Avoid unnecessary explanations.
‚Ä¢ Prioritize technical details over generic advice.

:::

## References

[How To Get The Most Out Of Vibe Coding](https://www.ycombinator.com/library/MN-how-to-get-the-most-out-of-vibe-coding), Y Combinator Startup School 


